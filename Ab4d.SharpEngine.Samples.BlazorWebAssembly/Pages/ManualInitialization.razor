@page "/manualInitialization"
@using System.Numerics
@using Ab4d.SharpEngine
@using Ab4d.SharpEngine.Cameras
@using Ab4d.SharpEngine.Common
@using Ab4d.SharpEngine.Materials
@using Ab4d.SharpEngine.SceneNodes
@using Ab4d.SharpEngine.Utilities
@using Ab4d.SharpEngine.WebGL
@using Ab4d.SharpEngine.Browser
@inject IJSRuntime JS  
@implements IDisposable

<PageTitle>Ab4d.SharpEngine.Web - Manual Initialization</PageTitle>

<h1>Ab4d.SharpEngine.Web</h1>

<p>This sample shows how to manually initialize the Ab4d.SharpEngine.Web.</p>
<p>Instead of using the SharpEngineSceneView component, here we create a canvas DOM element and then connect to it
    by using CanvasInterop. After that we can create the WebGLDevice, Scene and SceneView objects.
</p>


<canvas id="webGLCanvas" style="width: 70%; min-width: 400px; height: 500px; margin-top: 10pt; border: solid black 1px"></canvas>

@code
{
    private CanvasInterop? _canvasInterop;

    protected override async Task OnInitializedAsync()
    {
        // Initialize the browser interop (load sharp-engine.js file and from javascript get access to exported methods in the CanvasInterop class)
        // Because Blazor uses Single Page Applications style, this needs to be executed only once
        await CanvasInterop.InitializeInterop();
    }

    /// <inheritdoc />
    protected override void OnAfterRender(bool firstRender)
    {
        if (!CanvasInterop.IsInteropInitialized)
            return;


        // In OnAfterRender method all the DOM elements (including our canvas) have been initialized, so we can connect to them.
        // So we can create an instance of CanvasInterop class that will connect the SharpEngine with the canvas in the DOM.
        // NOTE: canvasId is the id of the canvas that shows WebGL graphics (see the html part of the code above)
        _canvasInterop = new CanvasInterop(canvasId: "webGLCanvas"); // if we do not need pointer events, we can also add: subscribePointerEvents: false

        // Try to connect to the canvas and get the WebGL context.
        // We can also skip this call. In this case InitWebGL will be called from the Scene or SceneView Initialized method.
        // But by calling this by ourselves, we can immediately check if the WebGL context is available (checking IsWebGLInitialized).
        _canvasInterop.InitWebGL();

        if (!_canvasInterop.IsWebGLInitialized)
            return; // Skip creating Scene and SceneView objects; error message was already written to console in the InitWebGL method


        var gpuDevice = WebGLDevice.Create(_canvasInterop); // We can also pass an EngineCreateOptions object to the Create method

        if (!gpuDevice.IsInitialized)
            return; // Blazor cannot use the WebGL context

        var scene = new Scene(gpuDevice, "MainScene");         // Create Scene object and also initialize it with the gpuDevice.
        var sceneView = new SceneView(scene, "MainSceneView");


        // You can also create the Scene and SceneView objects (and also add SceneNodes to the RootNode)
        // before initializing the WebGL device:
        //
        // var scene = new Scene("MainScene");
        // var sceneView = new SceneView(scene, "MainSceneView");

        // Later (even after adding some SceneNodes to the Scene), you can initialize the Scene and SceneView,
        // by one of the following options:

        // 1:
        //sceneView.Initialize(canvasInterop); // This will also call WebGLDevice.Create and will also initialize the Scene

        // 2:
        // var gpuDevice = WebGLDevice.Create(canvasInterop);
        // scene.Initialize(gpuDevice); // This will also initialize the SceneView and set its initial size

        // 3:
        // var gpuDevice = WebGLDevice.Create(canvasInterop);
        // sceneView.Initialize(gpuDevice); // This will also initialize the Scene


        //
        // Now we can create our 3D scene
        //

        var boxNode = new BoxModelNode(centerPosition: new Vector3(0, 0, 0), size: new Vector3(100, 40, 80), material: StandardMaterials.Green);
        scene.RootNode.Add(boxNode);


        sceneView.BackgroundColor = Colors.SkyBlue;

        sceneView.Camera = new TargetPositionCamera()
        {
            Heading = 30,
            Attitude = -20,
            Distance = 300
        };

        var pointerCameraController = new PointerCameraController(sceneView)
        {
            RotateCameraConditions = PointerAndKeyboardConditions.LeftPointerButtonPressed,
            MoveCameraConditions = PointerAndKeyboardConditions.LeftPointerButtonPressed | PointerAndKeyboardConditions.ControlKey,
            ZoomMode = CameraZoomMode.PointerPosition,
            RotateAroundPointerPosition = true,
            IsPinchZoomEnabled = true, // zoom with touch pinch gesture
            IsPinchMoveEnabled = true  // move camera with two fingers
        };
    }

    public void Dispose()
    {
        if (_canvasInterop != null)
        {
            _canvasInterop.Dispose(); // This will also dispose SceneView, Scene and WebGLDevice
            _canvasInterop = null;
        }
    }
}